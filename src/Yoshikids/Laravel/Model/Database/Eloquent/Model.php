<?php

namespace Yoshikids\Laravel\Model\Database\Eloquent;

use Yoshikids\Laravel\Model\Database\Query\Grammars\MySqlGrammar;
use Illuminate\Database\Connection;
use Illuminate\Database\MySqlConnection;
use Yoshikids\Laravel\Model\Database\Query\Builder as QueryBuilder;

use Illuminate\Database\Eloquent\Builder;

class Model extends \Illuminate\Database\Eloquent\Model
{
    const TYPE_ADJUST_ARRAY_DEFAULT         = 1;

    const INSTANCE_CACHE_TYPE_MEMCACHED     = 1;
    const INSTANCE_CACHE_TYPE_APC           = 2;
    const INSTANCE_CACHE_TYPE_REDIS         = 3;

    const NEGATIVE_CACHE_DISABLE            = 1;
    const NEGATIVE_CACHE_ENABLE             = 2;

    const LOCK_TYPE_FOR_UPDATE              = 1;
    const LOCK_TYPE_SHARED                  = 2;

    const DEFAULT_PAGINATE_PER_PAGE         = 20;

    /**
     * @param $lock_type
     * @return array
     */
    public static function getLockOptionArray($lock_type)
    {
        return ['lock_type' => $lock_type];
    }

    /**
     * @return int
     */
    public static function getPaginatePerPage()
    {
        return self::DEFAULT_PAGINATE_PER_PAGE;
    }

    /**
     * @explain array of fetched objects
     * @var  array
     */
    protected static $coherenceCache    = array();
    protected static $properties        = array();
    protected static $definedPrimaryKey = array();
    protected static $tableName         = null;
    protected static $instanceCacheType = null;
    protected static $negativeCacheType = self::NEGATIVE_CACHE_DISABLE;

    protected $insertIgnore = false;

    /**
     * @return null
     */
    public static function getTableName()
    {
        return static::$tableName;
    }

    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        static::saved(function(Model $model){
            $model->resetAdditionalAttribute();
            static::updateCoherenceCacheByObject($model);
        });
        static::deleted(function(Model $model){
            static::deleteCoherenceCacheByObject($model);
        });
    }

    /**
     * @explain
     */
    public static function clearCoherenceCache()
    {
        static::$coherenceCache = array();
    }

    /**
     * @param Builder $query
     * @param null $paginate_per_page
     * @return \Illuminate\Contracts\Pagination\LengthAwarePaginator|Builder[]|\Illuminate\Database\Eloquent\Collection
     */
    public static function switchGetOrPaginate(Builder $query, $paginate_per_page = null)
    {
        return $paginate_per_page === null ? $query->get() :  $query->paginate($paginate_per_page)->onEachSide(1);
    }

    /**
     * Implode the primary keys within the data into a string
     *
     * @param   array
     * @return  string
     */
    public static function implode_pk($object)
    {
        if (count(static::$definedPrimaryKey) == 1) {
            $p = reset(static::$definedPrimaryKey);
            return (is_object($object)
                ? strval($object->{$p})
                : (isset($object[$p])
                    ? strval($object[$p])
                    : null));
        }

        $pk = '';
        foreach (static::$definedPrimaryKey as $p) {
            if (is_null((is_object($object) ? $object->{$p} : (isset($object[$p]) ? $object[$p] : null)))) {
                return null;
            }
            $pk .= '[' . (is_object($object) ? $object->{$p} : $object[$p]) . ']';
        }

        return $pk;
    }

    public static function fromPks(array $id_array, string $con = null, $options = array())
    {
        $primary_keys   = static::$definedPrimaryKey;
        $pk_count       = count($primary_keys);
        if ($pk_count !== 1)
        {
            throw new \Exception('from_pks one primary key only.');
        }

        // for empty
        if (empty($id_array))
        {
            return array();
        }

        $column_name    = $primary_keys[0];
        $query          = static::on($con);
        $query->whereIn($column_name, $id_array);
        if ($query->getMacro('withTrashed') instanceof \Closure) {
            $query->withTrashed();
        }
        $result_objects = $query->get();
        foreach ($result_objects as $result_object)
        {
            $cache_pk[$column_name] = $result_object->$column_name;
            static::setCoherenceCache($cache_pk, $result_object);
        }

        return $result_objects;
    }

    /**
     * 主キーから検索(複数主キー対応済み)
     * @param $id
     * @param string|null $con
     * @param array $options
     * @return mixed|null
     * @throws \Exception
     */
    public static function fromPk($id, string $con = null, $options = array())
    {
        if (!is_array($id))
        {
            $id         = array($id);
        }

        $primary_keys   = static::$definedPrimaryKey;
        $pk_count       = count($primary_keys);
        if ($pk_count !== count($id))
        {
            throw new \Exception('fromPk count unmatch.');
        }

        $cache_pk = $where = array();
        foreach ($primary_keys as $pk)
        {
            $cache_pk[$pk] = current($id);
            next($id);
        }

        // キャッシュを使うべきかどうか
        $isCacheEnable = static::isEnableCache($con, $options);
        if ($isCacheEnable === true)
        {
            // インスタンスキャッシュが有効かどうか
            if (array_key_exists(get_called_class(), static::$coherenceCache)
                and array_key_exists(static::implode_pk($cache_pk), static::$coherenceCache[get_called_class()])
            )
            {
                return static::$coherenceCache[get_called_class()][static::implode_pk($cache_pk)];
            }
        }
        $result_object  = null;
        // キャッシュをすべきでない場合かキャッシュがヒットしない場合はクエリから取得する
        if ($isCacheEnable === FALSE || null === ($result_object = static::getFromCoherenceCache($cache_pk, static::$negativeCacheType)))
        {
            // キャッシュが無効な場合はインスタンスキャッシュを削除
            // Perform cleanup:
            // remove from internal object cache, remove PK's, set to non saved object, remove db original values
            if (array_key_exists(get_called_class(), static::$coherenceCache)
                and array_key_exists(static::implode_pk($cache_pk), static::$coherenceCache[get_called_class()])) {
                unset(static::$coherenceCache[get_called_class()][static::implode_pk($cache_pk)]);
            }

            // cacheから取得できない場合はクエリを発行
            $query              = static::on($con);
            switch ($options['lock_type'] ?? null)
            {
                case self::LOCK_TYPE_FOR_UPDATE:
                    $query->lockForUpdate();
                    break;
                case self::LOCK_TYPE_SHARED:
                    $query->sharedLock();
                    break;
            }
            $con                = $query->getConnection();
            foreach ($cache_pk as $pk => $value)
            {
                $query->where($pk, $value);
            }
            $query->limit(1);
            if ($query->getMacro('withTrashed') instanceof \Closure) {
                $query->withTrashed();
            }
            $result_object      = $query->get()->first();

            // トランザクション中はキャッシュしない
            if (false === ($con instanceof Connection &&
                    static::isConnectionInTransaction($con)))
            {
                try {
                    static::setToInstanceCache($cache_pk, $result_object, static::$negativeCacheType);
                } catch (\Psr\SimpleCache\InvalidArgumentException $e) {

                }
            }

            static::setCoherenceCache($cache_pk, $result_object);
        }

        return $result_object;
    }

    /**
     * @param Model $object
     */
    public static function updateCoherenceCacheByObject(Model $object)
    {
        static::$coherenceCache[get_called_class()][static::implode_pk($object)] = $object;
    }

    /**
     * @param Model $object
     */
    public static function deleteCoherenceCacheByObject(Model $object)
    {
        unset(static::$coherenceCache[get_called_class()][static::implode_pk($object)]);
    }

    /**
     * @param $cache_pk
     * @param $result_object
     */
    public static function setCoherenceCache($cache_pk, $result_object)
    {
        static::$coherenceCache[get_called_class()][static::implode_pk($cache_pk)] = $result_object;
    }

    /**
     * @param Connection $con
     * @return bool
     */
    public static function isConnectionInTransaction(Connection $con)
    {
        return $con->transactionLevel() !== 0;
    }

    protected static function isEnableCache(string $con = null, $options)
    {
        $result     = TRUE;
        $con        = \DB::connection($con);
        // トランザクション中は無効
        if (static::isConnectionInTransaction($con))
        {
            $result = FALSE;
        }

        // disable cache
        if (isset($options['cache']) &&
            $options['cache'] === FALSE
        )
        {
            return FALSE;
        }

        return $result;
    }

    protected static function getFromCoherenceCache($cache_pk, $negative_cache = self::NEGATIVE_CACHE_DISABLE)
    {
        $cache          = null;
        $called_class   = get_called_class();
        switch (static::$instanceCacheType)
        {
            case self::INSTANCE_CACHE_TYPE_MEMCACHED:
                $memcached  = \Cache::store('memcached');
                $cache      = $memcached->get($called_class . '_' . static::implode_pk($cache_pk));
                break;
            default:
                break;
        }

        if (static::$instanceCacheType !== null &&
            ($negative_cache === self::NEGATIVE_CACHE_ENABLE || $cache instanceof $called_class))
        {
            static::$coherenceCache[$called_class][static::implode_pk($cache)] = $cache;
        }

        return $cache;
    }

    /**
     * @param $cache_pk
     * @param $result_object
     * @param int $enable_negative_cache
     * @return bool
     * @throws \Psr\SimpleCache\InvalidArgumentException
     */
    protected static function setToInstanceCache($cache_pk, $result_object, $enable_negative_cache = self::NEGATIVE_CACHE_DISABLE)
    {
        $result         = FALSE;
        $called_class   = get_called_class();

        // bool値は設定させない
        if (FALSE === is_bool($result_object))
        {
            if ($enable_negative_cache === self::NEGATIVE_CACHE_ENABLE || $result_object instanceof $called_class)
            {
                switch (static::$instanceCacheType)
                {
                    case self::INSTANCE_CACHE_TYPE_MEMCACHED:
                        $memcached  = \Cache::store('memcached');
                        $result     = $memcached->set($called_class . '_' . static::implode_pk($cache_pk),
                            $result_object,
                            env('MEMCACHED_DEFAULT_TTL_MIN')
                        );
                        break;
                }
            }
        }

        return $result;
    }

    public static function getProperties()
    {
        return array_keys(static::$properties);
    }

    private function resetAdditionalAttribute()
    {
        $this->insertIgnore         = false;
    }

    /**
     * @param bool $value
     */
    public function setInsertIgnore(bool $value = true)
    {
        $this->insertIgnore         = $value;
    }

    protected function performInsert(Builder $query)
    {
        $query_builder = $query->getQuery();
        if ($query_builder instanceof \Yoshikids\Laravel\Model\Database\Query\Builder)
        {
            $query_builder->setInsertIgnore($this->insertIgnore);
        }
        $result = parent::performInsert($query); // TODO: Change the autogenerated stub;

        return $result;
    }

    /**
     * @return QueryBuilder|\Illuminate\Database\Query\Builder
     */
    protected function newBaseQueryBuilder()
    {
        $connection     = $this->getConnection();
        $grammar        = $connection->getQueryGrammar();
        if ($connection instanceof MySqlConnection)
        {
            $grammar    = new MySqlGrammar();
        }

        return new QueryBuilder(
            $connection, $grammar, $connection->getPostProcessor()
        );
    }

    /**
     * @explain toArray for Original output pattern
     * @return array
     */
    public function toAdjustArray($type = self::TYPE_ADJUST_ARRAY_DEFAULT)
    {
        switch ($type)
        {
            default:
                $output_array   = $this->toArray();
                break;
        }

        return $output_array;
    }

    public function toArray()
    {
        $output_array                   = parent::toArray();
        foreach (static::getProperties() as $key)
        {
            if (!isset($output_array[$key]))
            {
                $output_array[$key]     = null;
            }
        }

        return $output_array;
    }

    /**
     * @explain toAdjustArrayfor Objects
     * @param $objects
     * @param int $type
     * @return array
     */
    public static function batchAdjustArray($objects, $type = self::TYPE_ADJUST_ARRAY_DEFAULT)
    {
        $result_array           = array();
        foreach ($objects as $object)
        {
            if ($object instanceof static)
            {
                $result_array[] = $object->toAdjustArray($type);
            }
        }

        return $result_array;
    }

    /******************************
     * For Multiple Primary Key
     ******************************/
    /**
     * Set the keys for a save update query.
     *
     * @param  \Illuminate\Database\Eloquent\Builder  $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    protected function setKeysForSaveQuery(Builder $query)
    {
        // get the keys
        $keys = $this->getKeyForSaveQuery();
        // iterate through the key(s)
        foreach ($keys as $key => $value) {
            $query->where($key, '=', $value);
        }
        // return the query
        return $query;
    }
    /**
     * Get the primary key value for a save query.
     *
     * @return mixed
     */
    protected function getKeyForSaveQuery()
    {
        // get the primary key
        $primaryKeys = $this->getKeyName();
        // ensure that the keys are in an array
        if (! is_array($primaryKeys)) {
            $primaryKeys = [$primaryKeys];
        }
        // define the return data
        $result = [];
        // iterate through the key(s)
        foreach ($primaryKeys as $key) {
            if (isset($this->original[$key])) {
                $result[$key] = $this->original[$key];
            } else {
                $result[$key] = $this->getAttribute($key);
            }
        }
        // return the keys
        return $result;
    }
}
